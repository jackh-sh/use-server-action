# Middleware

Middleware allows you to wrap server actions with reusable logic like authentication, validation, logging, and more.

```ts
import {
    createMiddleware,
    applyMiddleware,
    composeMiddleware,
    withValidation,
    withLogging,
} from "use-server-action/server";
```

## Creating Middleware

Use `createMiddleware` to create a type-safe middleware function:

```ts
const withAuth = createMiddleware(async (next, ...params) => {
    const user = await getUser();

    if (!user) {
        return { ok: false, message: "Unauthorized", code: "UNAUTHORIZED" };
    }

    // Call next to continue the chain
    return next(...params);
});
```

### Middleware Capabilities

Middleware can:

1. **Short-circuit** - Return early without calling `next`
2. **Modify parameters** - Transform input before passing to `next`
3. **Modify results** - Transform the result after calling `next`
4. **Add side effects** - Logging, analytics, etc.

```ts
// Example: Modify parameters
const withTrimmedInput = createMiddleware(async (next, input: string) => {
    return next(input.trim());
});

// Example: Modify results
const withTimestamp = createMiddleware(async (next, ...params) => {
    const result = await next(...params);
    if (result.ok) {
        return {
            ...result,
            data: { ...result.data, timestamp: Date.now() },
        };
    }
    return result;
});
```

## Applying Middleware

Use `applyMiddleware` to wrap an action with middleware:

```ts
import { serverAction, applyMiddleware } from "use-server-action/server";

const createPost = serverAction(async (title: string) => {
    return await db.post.create({ data: { title } });
});

export const protectedCreatePost = applyMiddleware(createPost, [
    withAuth,
    withLogging,
]);
```

Middleware executes in order - `withAuth` runs first, then `withLogging`, then the action.

## Composing Middleware

Use `composeMiddleware` to combine multiple middleware into one:

```ts
const withProtection = composeMiddleware(
    withAuth,
    withRateLimit,
    withLogging
);

// Use as a single middleware
export const protectedAction = applyMiddleware(myAction, [withProtection]);
```

## Built-in Middleware

### withValidation

Validates input against a Zod-compatible schema:

```ts
import { z } from "zod";
import { withValidation, applyMiddleware, serverAction } from "use-server-action/server";

const CreateUserSchema = z.object({
    name: z.string().min(1, "Name is required"),
    email: z.string().email("Invalid email"),
});

const createUser = serverAction(async (input: z.infer<typeof CreateUserSchema>) => {
    return await db.user.create({ data: input });
});

export const validatedCreateUser = applyMiddleware(createUser, [
    withValidation(CreateUserSchema),
]);
```

#### Options

```ts
withValidation(schema, {
    // Custom error code (default: "VALIDATION_ERROR")
    code: "INVALID_INPUT",

    // Custom error message formatter
    formatError: (error) => {
        return error.errors?.map(e => e.message).join(", ") ?? "Invalid input";
    },
});
```

#### Compatible Libraries

`withValidation` works with any library that has a compatible `safeParse` method:

- [Zod](https://zod.dev)
- [Valibot](https://valibot.dev)
- Any custom schema with `safeParse(data) => { success: boolean, data?, error? }`

### withLogging

Logs action calls and results:

```ts
import { withLogging } from "use-server-action/server";

const logger = withLogging({
    onCall: (params) => {
        console.log("Action called with:", params);
    },
    onSuccess: (data, params) => {
        console.log("Action succeeded:", data);
    },
    onError: (message, code, params) => {
        console.error(`Action failed [${code}]:`, message);
    },
});

export const loggedAction = applyMiddleware(myAction, [logger]);
```

## Common Patterns

### Authentication Middleware

```ts
const withAuth = createMiddleware(async (next, ...params) => {
    const session = await getSession();

    if (!session?.user) {
        return { ok: false, message: "Please sign in", code: "UNAUTHORIZED" };
    }

    return next(...params);
});
```

### Role-Based Access

```ts
const withRole = (role: string) =>
    createMiddleware(async (next, ...params) => {
        const user = await getUser();

        if (!user) {
            return { ok: false, message: "Unauthorized", code: "UNAUTHORIZED" };
        }

        if (user.role !== role) {
            return { ok: false, message: "Forbidden", code: "FORBIDDEN" };
        }

        return next(...params);
    });

// Usage
export const adminAction = applyMiddleware(myAction, [withRole("admin")]);
```

### Rate Limiting

```ts
const rateLimit = new Map<string, number[]>();

const withRateLimit = (limit: number, windowMs: number) =>
    createMiddleware(async (next, ...params) => {
        const ip = headers().get("x-forwarded-for") ?? "unknown";
        const now = Date.now();
        const windowStart = now - windowMs;

        const requests = rateLimit.get(ip)?.filter(t => t > windowStart) ?? [];

        if (requests.length >= limit) {
            return {
                ok: false,
                message: "Too many requests",
                code: "RATE_LIMITED",
            };
        }

        requests.push(now);
        rateLimit.set(ip, requests);

        return next(...params);
    });

// Usage: 10 requests per minute
export const limitedAction = applyMiddleware(myAction, [
    withRateLimit(10, 60000),
]);
```

### Error Logging

```ts
const withErrorLogging = createMiddleware(async (next, ...params) => {
    const result = await next(...params);

    if (!result.ok) {
        // Send to error tracking service
        await trackError({
            message: result.message,
            code: result.code,
            params,
        });
    }

    return result;
});
```

## Execution Order

When applying multiple middleware, they execute in a "wrap" pattern:

```ts
const wrapped = applyMiddleware(action, [first, second, third]);
```

Execution flow:
1. `first` runs (before)
2. `second` runs (before)
3. `third` runs (before)
4. `action` runs
5. `third` completes (after)
6. `second` completes (after)
7. `first` completes (after)

This is similar to how Express middleware or Koa middleware works.
