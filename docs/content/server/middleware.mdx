# Middleware

Middleware allows you to wrap server actions with reusable logic like authentication, validation, logging, and more.

```ts
import {
    createAction,
    createMiddleware,
    createContextMiddleware,
    withZodValidation,
    withLogging,
} from "use-server-action/server";
```

## Creating Middleware

Use `createMiddleware` to create a type-safe middleware function:

```ts
const withAuth = createMiddleware(async (next, ...params) => {
    const user = await getUser();

    if (!user) {
        return { ok: false, message: "Unauthorized", code: "UNAUTHORIZED" };
    }

    return next(...params);
});
```

### Middleware Capabilities

Middleware can:

1. **Short-circuit** - Return early without calling `next`
2. **Modify parameters** - Transform input before passing to `next`
3. **Modify results** - Transform the result after calling `next`
4. **Add side effects** - Logging, analytics, etc.

```ts
// Example: Modify parameters
const withTrimmedInput = createMiddleware(async (next, input: string) => {
    return next(input.trim());
});

// Example: Modify results
const withTimestamp = createMiddleware(async (next, ...params) => {
    const result = await next(...params);
    if (result.ok) {
        return {
            ...result,
            data: { ...result.data, timestamp: Date.now() },
        };
    }
    return result;
});
```

## Applying Middleware

Use the `createAction` builder to apply middleware with `.use()`:

```ts
import { createAction, createMiddleware } from "use-server-action/server";

export const protectedCreatePost = createAction<{ title: string }>()
    .use(withAuth)
    .use(withLogging)
    .handle(async (ctx, input) => {
        const post = await db.post.create({ data: { title: input.title } });
        return { ok: true, data: post };
    });
```

Middleware executes in order - `withAuth` runs first, then `withLogging`, then the action.

## Composing Middleware

Chain multiple `.use()` calls to compose middleware:

```ts
export const protectedAction = createAction<string>()
    .use(withAuth)
    .use(withRateLimit)
    .use(withLogging)
    .handle(async (ctx, input) => {
        return { ok: true, data: input };
    });
```

## Execution Order

When applying multiple middleware, they execute in a "wrap" pattern:

```ts
const wrapped = createAction<string>()
    .use(first)
    .use(second)
    .use(third)
    .handle(async (ctx, input) => { ... });
```

Execution flow:
1. `first` runs (before)
2. `second` runs (before)
3. `third` runs (before)
4. `action` runs
5. `third` completes (after)
6. `second` completes (after)
7. `first` completes (after)

This is similar to how Express or Koa middleware works.

## Built-in Middleware

The following middleware is provided out of the box:

- [withLogging](/server/with-logging) - Log server action calls
- [withZodValidation](/server/with-zod-validation) - Validate input against a Zod schema

## Context-Aware Middleware

For scenarios where middleware needs to pass data to downstream middleware or the action (like user information from authentication), use context middleware.

### Creating Context Middleware

Use `createContextMiddleware` to create middleware that adds to a shared context:

```ts
import { createContextMiddleware } from "use-server-action/server";

type User = { id: string; name: string };

const withAuth = createContextMiddleware<
    [string],        // Action parameters
    any,             // Action return type
    {},              // Input context (what this middleware expects)
    { user: User }   // Output context (what this middleware adds)
>(async (next, ctx, input) => {
    const user = await authenticate();

    if (!user) {
        return { ok: false, message: "Unauthorized", code: "UNAUTHORIZED" };
    }

    return next({ ...ctx, user }, input);
});
```

### Using Context in Actions

The action handler receives the accumulated context from all middleware:

```ts
import { createAction, createContextMiddleware } from "use-server-action/server";

type User = { id: string; name: string };
type Database = { query: (sql: string) => Promise<any> };

const withAuth = createContextMiddleware<
    [string], any, {}, { user: User }
>(async (next, ctx, postId) => {
    const user = await getAuthenticatedUser();
    if (!user) {
        return { ok: false, message: "Unauthorized", code: "UNAUTHORIZED" };
    }
    return next({ ...ctx, user }, postId);
});

const withDb = createContextMiddleware<
    [string], any, { user: User }, { db: Database }
>(async (next, ctx, postId) => {
    const db = await getDbConnection(ctx.user.id);
    return next({ ...ctx, db }, postId);
});

export const getPost = createAction<[string]>()
    .use(withAuth)
    .use(withDb)
    .handle(async (ctx, postId) => {
        // ctx.user and ctx.db are fully typed!
        const post = await ctx.db.query(`SELECT * FROM posts WHERE id = ${postId}`);
        return { ok: true, data: post };
    });

// Call the action
const result = await getPost("post-123");
```

### Type Safety

The context system is fully type-safe:

- Each middleware declares what context it **requires** and what it **provides**
- TypeScript ensures middleware is chained correctly
- The final action receives the accumulated context type

```ts
// This causes a TypeScript error - withDb requires { user: User }
const broken = createAction<[string]>()
    .use(withDb)      // Error: Property 'user' is missing
    .use(withAuth)
    .handle(async (ctx, id) => { ... });

// Correct order
const working = createAction<[string]>()
    .use(withAuth)    // Adds { user: User }
    .use(withDb)      // Receives { user: User }, adds { db: Database }
    .handle(async (ctx, id) => { ... });
```

### When to Use Context vs Regular Middleware

| Use Case | Recommendation |
|----------|----------------|
| Simple validation/auth that doesn't share data | Regular middleware (`createMiddleware`) |
| Logging, analytics, timing | Regular middleware |
| Auth that passes user info to the action | Context middleware (`createContextMiddleware`) |
| Database connections scoped to request | Context middleware |
| Any chain where data flows between layers | Context middleware |

---

## Legacy APIs (Deprecated)

The following APIs are deprecated. Use `createAction().use(middleware).handle(fn)` instead.

### applyMiddleware

```ts
import { serverAction, applyMiddleware } from "use-server-action/server";

const createPost = serverAction(async (title: string) => {
    return await db.post.create({ data: { title } });
});

export const protectedCreatePost = applyMiddleware(createPost, [
    withAuth,
    withLogging,
]);
```

**Migrate to:**

```ts
export const protectedCreatePost = createAction<{ title: string }>()
    .use(withAuth)
    .use(withLogging)
    .handle(async (ctx, input) => {
        const post = await db.post.create({ data: { title: input.title } });
        return { ok: true, data: post };
    });
```

### composeMiddleware

```ts
const withProtection = composeMiddleware(
    withAuth,
    withRateLimit,
    withLogging
);

export const protectedAction = applyMiddleware(myAction, [withProtection]);
```

**Migrate to:**

```ts
export const protectedAction = createAction<string>()
    .use(withAuth)
    .use(withRateLimit)
    .use(withLogging)
    .handle(async (ctx, input) => {
        return { ok: true, data: input };
    });
```
